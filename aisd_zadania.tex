\documentclass[10pt]{article}%

\usepackage{algpseudocode, algorithm2e}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{flexisym}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}

\newcommand{\beginsolution}{\textbf{\\~\\ \textbf{Rozwiązanie:} \\~\\}}
\newcommand{\finishsolution}{\\~\\ \noindent\rule{11cm}{0.4pt}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Schemat dodawania zadań: dodać do odpowiedniego działu jako \item, w nawiasie dodać orientacyjny numer 
% (być może zrezygnujemy z numerów), miesiąc i rok zadania. 
% Rozwiązanie dodajemy korzystając z komend 
% \beginsolution \finishsolution (nie mogłem nazwać endsolution)
% Ogólnie:
% \subsection{Nazwa działu}
% \begin{enumerate}
% 
% \item Treść zadania
% \beginsolution Tu wpisujesz rozwiązanie
% \finishsolution
%
% \item ...
% ...
%
% \end{enumerate}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

\section*{AiSD wszystkie - wersja z dnia \today}


\section*{Zadania z części 1.}


\subsection*{Drzewa AVL, B-drzewa}

\begin{enumerate}

\item (Zad. 12, cz. 1, 06.2017) Jak mocno można ograniczyć (w pesymistycznym przypadku) liczbę rotacji podczas usuwania wierzchołka z drzewa AVL o $n$ wierzchołkach? Uzasadnij, że nie da się bardziej niż podałeś(aś).

\item (Zad. 19, cz. 1, 06.2016) Jaką największą wysokość może mieć drzewo AVL zawierające 67 kluczy? Odpowiedź uzasadnij.
\beginsolution
Zbudujmy drzewo AVL o maksymalnej wysokości przy użyciu jak najmniejszej ilości wierzchołków. Nazwijmy je $T_i$ Dla $T_0 = 0$ będzie to drzewo puste, dla $T_1 = 1$ będzie to drzewo jednoelementowe, dla $T_2 = 2$ będzie to drzewo składające się z korzenia i jednego syna. Dla $T_n$, gdzie $n \geq 3$ będzie to drzewo które składa się z korzenia i dwóch poddrzew, którymi są drzewa o wysokości $T_{n-1}$ oraz $T_{n-2}$. Drzewa te nazywamy drzewami Fibbonacciego. Liczba wierzchołków takiego drzewa to $N_h = N_{h-1} + 1 + N_{h-2}$. W takim razieiczba wierzchołków kolejnych drzew Fibbonacciego to odpowiednio $0, 1, 2, 4, 7, 12, 20, 33, 54, 88, \ldots $. Drzewo o 67 kluczach będzie miało więc maksymalnie wysokość 8, ponieważ, żeby zbudować drzewo AVL o wysokości $9$ potrzeba minimum 88 kluczy. 
\finishsolution

\item (Zad. 14, cz. 1, 06.2015) Jeśli w drzewach AVL zmienilibyśmy warunek, by poddrzewa mogły różnić się o 2 (nie o 1) wysokością, to Czy drzewo n-wierzchołkowe dalej ma wysokość $\Theta(n)$? 

\item (Zad. 09, 06.2017) Rozważamy \emph{B} drzewa, których wierzchołki mogą pamiętać od dwóch do czterech kluczy. Narysuj, jak będzie wyglądać takie \emph{B} drzewo po wstawieniu do początkowego pustego drzewa kolejno klucz $1,2,\ldots,10$.

\end{enumerate}


\subsection*{Drzewa Splay}

\begin{enumerate}

\item (Zad. 3, cz. 1, 06.2017) Narysuj 
\begin{itemize}
	\item drzewo \emph{Splay} po wykonaniu na początkowo pustym drzewie ciągu operacji: $$insert(n),insert(n-1),insert(n-2),...,(insert(1),$$
	\item drzewo \emph{Splay} po wykonaniu operacji \emph{Splay(n), Splay(n-1)} na drzewie otrzymanym w poprzednim punkcie
\end{itemize}

\item (Zad. 6, cz. 1, 06.2016) Czy trójelementowe drzewo złożone z korzenia i dwóch jego synów może być drzewem splay? Odpowiedź uzasadnij.

\end{enumerate}


\subsection*{Haszowanie}

\begin{enumerate}

\item (Zad. 6, cz. 1, 06.2017) Rozważamy haszowanie metodą adresowania otwartego, w której konflikty rozwiązujemy metodą liniową. Pokaż, że po umieszczeniu $n/2$ kluczy w tablicy $n$ elementowej, mogą istnieć dwie lokalizacje w tej tablicy, do których kolejny (tj. ($n/2 + 1$)szy) klucz ma szansę trafić z prawdopodobieństwem $1/n$.

\item (Zad. 15, cz. 1, 06.2017) Ile pamięci zajmuje słownik statyczny (oparty o haszowanie dwupoziomowe) zawierający $n$ kluczy? Co musimy w nim pamięta ć oprócz samych kluczy?

\item (Zad. 16, cz. 1, 06.2017) Podaj definicję i przykład uniwersalnej rodziny funkcji haszujących.

\item (Zad. 20, cz. 1, 06.2016) Jaka jest oczekiwana liczba kolizji podczas wstawiania $n$ kluczy do tablicy o $ m = n^2 $ elementach, jeśli do wyznaczania miejsc wstawiania użyjemy funkcji o postaci $h(k) = ((ak + b)$ mod $p)$ mod $m$, gdzie:

\item (Zad. 12, cz. 1, 06.2015) Oszacuj prawdopodobieństwo, że nie będzie żadnej kolizji podczas haszowania funkcją z uniwersalnej rodziny $\sqrt{n}$ kluczy w tablicy rozmiaru n. 

\end{enumerate}


\subsection*{FFT}

\begin{enumerate}

\item (Zad. 17, cz. 1, 06.2017) Algorytm FFT używaliśmy do zamiany reprezentacji wielomianu w reprezentację jako zbiór wartości wielomianu. Uzasadnij, dlaczego FFT możemy także zastosować do zamiany odwrotnej.

\item (Zad. 16, cz. 1, 06.2016) Jak wiadomo FFT jest algorytmem opartym na strategii Dziel i Zwyciężaj. Przedstaw redukcję wykonaną w tym algorytmie.

\item (Zad. 5, cz. 1, 06.2015) Przedstaw macierze dla transformacji Fouriera (???)

\end{enumerate}


\subsection*{Algorytmy wyszukiwania wzorca: KMP, KMR, Shift-And}

\begin{enumerate}

\item (Zad. 8, cz. 1, 06.2017) Czy istnieje wzorzec o długości $n$ (dla dowolnego $n>5$) nad alfabetem $\{a,b\}$, dla którego maksymalna wartość funkcji prefiksowej $\pi$ jest równa 
\begin{itemize}
\item[a] 0,
\item[b] 1?
\end{itemize}

\item (Zad. 11, cz. 1, 06.2017) W algorytmie \emph{Shift And} wykorzystywane są operacje logiczne na słowach maszynowych. Wytłumacz, w jaki sposób?

\item (Zad. 8, cz. 1, 06.2016) Dlaczego algorytm \textit{Shift-And} stosowany jest jedynie do wyszukiwania krótkich wzorców?

\item (Zad. 10, cz. 1, 06.2016) Jaka jest największa wartość funkcji $\pi$ dla wzorca $ P = (ab)^k$? Odpowiedź uzasadnij.

\item (Zad. 1, cz. 1, 06.2015) Podaj przykład tekstu i wzorca dla których tablica C[0] = C[1] = C[9] = prawda, a dla pozostałych fałsz. Algorytm Shift-And.

\item (Zad. 2, cz. 1, 06.2015) Jak w KMR numeruje się słowa o długości 16?

\item (Zad. 4, cz. 1, 06.2015) Uzasadnij, że obliczenie funkcji pi(Wzorzec[1..m]) w algorytmie KMP ma złożoność O(m).

\end{enumerate}


\subsection*{Algorytmy klasy NP i NC}

\begin{enumerate}

\item (Zad. 5, cz. 1, 06.2016) Opisz ideę algorytmu klasy NC dla problemu dodawania liczb naturalnych.

\item (Zad. 15, cz. 1, 06.2016) Podaj definicję problemu plecakowego z powtórzeniami i przedstaw pseudowielomianowy algorytm rozwiązujący ten problem. Uzasadnij, że jest on pseudowielomianowy.

\item (Zad. 13, cz. 1, 06.2015) Podaj pseudowielomianowy algorytm, który wypisuje dzielniki pierwsze liczby n.

\end{enumerate}


\subsection*{Drzewce}

\begin{enumerate}

\item(Zad. 4, cz. 1, 06.2017) Podaj przykład drzewca (tj. podaj wartość kluczy wraz z przydzielonymi im priorytetami) o n wierzchołkach, w którym każdy wierzchołek wewnętrzny ma tylko prawego syna. Następnie podaj, który wierzchołek będzie wymagał najwięcej rotacji podczas ustawiania go. Ile to będzie rotacji? Odpowiedź uzasadnij.

\item (Zad. 4, cz. 1, 06.2016) Narysuj ciąg rotacji, które zostaną wykonane w trakcie wykonywania \textbf{delete(p)} na poniższym drzewcu. Litery w wierzchołkach drzewca oznaczają klucze, a liczby w nawiasach - priorytety. Rotacje wypisz w kolejności wykonywania.
\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.4]{z40616.png}
	\end{center}
	\caption{rys do zad 4}
\end{figure}

\item (Zad. 8, cz. 1, 06.2015) Przedstaw drzewiec o n wierzchołkach, w którym usunięcie korzenia wymaga $\Omega(\sqrt{n})$ operacji, ew. podaj uzasadnienie dlaczego nie ma takiego drzewca.


\end{enumerate}


\subsection*{Drzewa decyzyjne, gra z adwersarzem}

\begin{enumerate}

\item (Zad. 5, cz. 1, 06.2017) Dolną granicę $\lceil \frac{3}{2} n - 2 \rceil $ na liczbę porównań niezbędnych do wyznaczenia \emph{max} i \emph{min} w zbiorze \emph{n} elementów można wykazać stosując grę z adwersarzem. Opisz skuteczną strategię w takiej grze. Jeśli jest to strategia opisana na wykładzie, możesz na tym poprzestać. Jeśli jest to inna strategia, wykaż, że jest skuteczna.

\end{enumerate}


\subsection*{Algorytmy wyboru k-tego elementu (mediany)}

\begin{enumerate}

\item (Zad. 7, cz. 1, 06.2017) Opisz w jaki sposób wybierany jest \emph{pivot} w każdym z następujących z następujących algorytmów znajdowania $k$-tego elementu: 
\begin{itemize}
	\item Algorytm Hoare'a,
	\item Algorytm Magicznych Piątek,
	\item Lazy Select.
\end{itemize}

\item (Zad. 7, cz. 1, 06.2016) Opisz ideę algorytmu znajdowania mediany opartego na idei próbkowania losowego.

\item (Zad. 16, cz. 1, 06.2015) Przerób kod QuickSorta na QuickSelect (selekcja k-tego elementu zamiast sortowania). Jaką ma złożoność?

\item (Zad. 19, cz. 1, 06.2015) Podaj wzór rekurencyjny algorytmu magicznych piątek dla podziału na 7 elementów. 

\end{enumerate}


\subsection*{Izomorfizm drzew}

\begin{enumerate}

\item (Zad. 10, cz. 1, 06.2017) Porównaj trudność problemu sprowadzania izomorfizmu drzew ukorzenionych i problemu sprawdzaniaa izomorfizmu drzew nieukorzenionych.

\item (Zad. 13, cz. 1, 06.2016) Przedstaw ideę szybkiego algorytmu sprawdzania izomorfizmu drzew. W jakim czasie działa ten algorytm?

\end{enumerate}


\subsection*{Geometria obliczeniowa}

\begin{enumerate}

\item (Zad. 14, cz. 1, 06.2017)W jaki sposób, stosując iloczyn wektorowy można sprawdzić, czy dwa punkty (powiedzmy $p_1$ i $p_2$) leżą po tej samej stronie prostej przechodzącej przez dwa punkty (powiedzmy A i B)?

\end{enumerate}


\subsection*{Union Find}

\begin{enumerate}

\item (Zad. 18, cz. 1, 06.2017) W analizie problemu \emph{Union Find} wykorzystywaliśmy pojęcie rzędu wierzchołka oraz grupy rzędu. Przypomnij definicję tych pojęć. Ile maksymalnie bitów potrzebujemy przeznaczyć na pamiętanie rzędu w każdym wierzchołku?

\item (Zad. 14, cz. 1, 06.2016) W jakim czasie można wykonać ciąg $n$ operacji \textbf{union} i \textbf{find}, w którym wszystkie operacje \textbf{union} poprzedzają operację \textbf{find}? Odpowiedź uzasadnij.

\item (Zad. 6, cz. 1, 06.2015) Podaj definicje: rząd wierzchołka i grupa rzędu wierzchołka

\end{enumerate}


\subsection*{Drzewa Van Emde Boasa}

\begin{enumerate}
\item (Zad. 19, cz. 1, 06.2017) Wyjaśnij po co oamiętane są wartości \emph{min} i \emph{max} w ja zdeh strukturze rekurencyjnej w drzewach (kolejkach van Emde Boasa)

\item (Zad. 9, cz. 1, 06.2016) Opisz (albo zapisz w pseudokodzie), w jaki sposób wykonywana jest operacja wstawiania klucza w drzewie van Emde Boasa.

\end{enumerate}


\subsection*{Kopce - zwykłe, dwumianowe, Fibonacciego}

\begin{enumerate}

\item (Zad. 2, cz. 1, 06.2017) Ile maksymalnie operacji \textit{join} wykona się podczas łączenia kopców dwumianowych (wersja eager), z których każdy zawiera nie więcej niż 500 elementów? Przypomnienie: operacja \textit{join} łączy dwa drzewa dwumianowe tego samego rzędu.

\item (Zad. 13, cz. 1, 06.2017) Niech $T_{1}$ oznacza najmniejsze pod względem liczby wierzchołków drzewo o rzędzie $i$, które może zawierać kopiec Fibonacciego. Narysuj drzewa $T_{i}$, dla $i = 0,1,\ldots,6$.

\item (Zad. 1, cz. 1, 06.2016) W jakim czasie można wykonać operację succ(x) w:
\begin{itemize}
\item kopcu,
\item kopcu dwumianowym,
\item kopcu Fibonacciego,
\end{itemize}
która znajduje następnik klucza znajdującego się w wierzchołku o adresie x? Przez następnik klucza $k$ rozumiemy najmniejszy występujący w kopcu klucz $k\textprime$ taki, że $k\textprime$ taki, że $ k\textprime > k$. Jeśli$k$ jest największym kluczem w kopcu, to $k\textprime = \infty$. Możesz założyć, że wszystkie klucze w kopc są unikalne. Odpowiedź uzasadnij.
\item (Zad. 17, cz. 1, 06.2016) Napisz w pseudokodzie szybką procedurę budowy kopca. W jakim czasie działa ta procedura?

\item (Zad. 18, cz. 1, 06.2016) Wyjaśnij, na czym polega operacja kaskadowego odcinania w kopcu Fibonacciego.

\item (Zad. 10, cz. 1, 06.2015) Ile jest maksymalnie drzew w kopcu:

\item (Zad. 11, cz. 1, 06.2015) Złożoność procedury budującej kopiec (wersja z przesun-do-gory()).

\item (Zad. 17, cz. 1, 06.2015) Porównanie kosztów operacji { min, delmin, insert, meld } dla kopców dwumianowych w wersji Lazy i Eager.

\item (Zad. 18, cz. 1, 06.2015) 
\begin{itemize}
	\item Podaj definicje rzędu drzewa w kopcu Fibbonaciego, 
	\item Podaj górne ograniczenie na ten rząd, 
	\item Podaj ideę dowodu tego ograniczenia. 
\end{itemize}

\end{enumerate}


\subsection*{Algorytmy znajdowania MST}
\begin{itemize}

\item (Zad. 11, cz. 1, 06.2016) W jakim czasie działa algorytm Kruskala, jeśli:
\begin{itemize}
	\item krawędzie podane są w kolejności rosnących wag,,
	\item kolejka priorytetowa zaimplementowana jest przy pomocy kopca Fibonacciego.
\end{itemize}
Odpowiedź uzasadnij. \textit{Uwaga: Oba te warunki są spełnione jednocześnie}

\item (Zad. 20, cz. 1, 06.2015) Przykład grafu pełnego o n wierzchołkach takiego, że algorytm Boruvki znajdzie MST w jednej fazie.

\end{itemize}


\subsection*{Różne algorytmy}

\begin{enumerate}

\item(Zad. 1, cz. 1, 06.2017)
Opisz algorytm oparty na programowaniu dynamicznym wyznaczający optymalną kolejność mnożenia macierzy. Jaka jest jego złożoność? Jeśli jest to algorytm podany na wykładzie, możesz na tym poprzestać, w przeciwnym razie uzasadnij jego poprawność i złożoność.

\item (Zad. 20, cz. 1, 06.2017) Przypomnij sobie algorytm oparty na zasadzie \emph{Dziel i zwyciężaj}, dla problemu znajdowania najbliższej pary punktów na płaszczyźnie. Opisz trzecią fazę algorytmu, a więc tę, która następuje po wywołaniach rekurencyjnych. Jaka jest jej złożoność?

\item (Zad. 12, cz. 1, 06.2016) Zapisz w pseudokodzie algorytm wielomianowy, znajdujący minimalny koszt obliczenia iloczynu ciągu macierzy.

\item (Zad. 15, cz. 1, 06.2015) Podaj pseudokod rozwiązania problemu LCS.

\end{enumerate}

\subsection*{Inne}

\begin{enumerate}

\item (Zad. 2, cz. 1, 06.2016) Rozwiąż rozwiązanie rekurencyjne (z redukcją do pierwiastka):
$$T(n) = \left\{\begin{array}{rcl}
1&:&n=1\\
T(\sqrt{n}+O(1)&:&wpp\\
\end{array} \right.$$
Możesz ograniczyć się do rozwiązania dla $n$ mających odpowiednią postać (taką, by w trakcie redukcji argumenty dla $T$ były liczbami naturalnymi).

\item (Zad. 3, cz. 1, 06.2016) Narysuj sieć Benesa-Waksmana dla n = 8.

\item (Zad. 3, cz. 1, 06.2015) Przedstaw graficznie sieć komparatorów o głębokości $\leq$ 4 sortującej wszystkie ciągi 0-1 o długości 7.

\item (Zad. 9, cz. 1, 06.2015) Podaj rekurencyjny wzór na T(n) tak, by jego rozwiązanie było $O(\log \log n)$.

\item (Zad. 7, cz. 1, 06.2015) Czy drzewa A i B będą miały równą wysokość, jeśli przeprowadzi się na nich n operacji insert o wartościach:
\begin{itemize}
	\item dla A: 1, 2, 3, ..., n 
	\item dla B: n, n-1, ..., 2, 1 
\end{itemize}

\end{enumerate}




\section*{Zadania z części 2.}

\begin{enumerate}

\item (Zad. 1, cz. 2, 06.2017) Przypomnijmy problem przechodzenia przez tablicę: \\
\noindent\textbf{Problem} (Przejście przez tablicę) \\
\indent \textbf{Dane:} Tablica $\{i,j\}$ liczb nieujemnych $(i=1,\ldots,n; j=1,\ldots,m)$ \\
\indent \textbf{Wynik:} Ciąg indeksów $i_1, \ldots, i_n$ taki, że $\forall_{j=1,\ldots,m-1} 1 \leq i_j \leq n$ oraz $| i_j - i_{j+1} | \leq 1$ maksymalizujący sumę $\sum_{j=1}^m a_{i_j,j}$ \\~\\
Ułóż algorytm dla następującego uogólnienia tego problemu: \\
\noindent\textbf{Problem} \\~\\
\indent \textbf{Dane:} Tablica $\{ a_{i,j} \} $ liczb nieujemnych $(i=1,\ldots,n; j=1,\ldots,m)$\\
\indent \textbf{Wynik:} Dla każdych $i,j$ takich, że $i=1,\ldots,n;j=1,\ldots,m$ należy podać największą wartość, po dodaniu której do $a_{i,j}$ wartość rozwiązania \textit{problemu przejścia przez tablicę} nie ulegnie zmianie. \\~\\

\item (Zad. 2, cz. 2, 06.2017) Dla zbiorów $n$ chłopców i $n$ dziewcząt chcemy znaleźć skojarzenia między nimi (tj. zbiór $n$ par (chłopiec, dziewczynka)), które minimalizują średnią różnicę wzrostu w parze. Dokładniej: dane są dwa $n$ - elementowe ciągi liczb naturalnych $C = c_1, c_2,\ldots, c_n$ oraz $D = d_1, d_2, \ldots, d_n$, gdzie $c_i$ jest wzrostem $i$-tego chłopca, a $d_i$ wzrostem $i$-tej dziewczynki (abstrahujemy od rzeczywistości $c_i$ oraz $d_i$ mogą być dowolnie duże). Chcemy znaleźć taką $n$-elementową permutację $\Pi$, że wartość $$\frac{\sum_{i=1}^n | c_i - d_{\Pi(i)}|}{n}$$ jest minimalna. \\
\begin{itemize}
\item Rozwiąż następujący algorytm zachłanny: w $i$-tym kroku $(i=1,2,\ldots,n)$ spośród nieskojarzonych jeszcze chłopców i dziewcząt kojarzymy parę o najmniejszej różnicy  wzrostów. Czy ten algorytm jest poprawny? Udowodnij swoje stwierdzenie.
\item Podaj lepszy algorytm dla tego problemu , tzn. poprawny w przypadku, gdy powyższy jest niepoprawny, bądź, szybszy (i oczywiście poprawny) w przypadku, gdy powyższy jest poprawny. Udowodnij poprawność swojego algorytmu i podaj złożoność.
\end{itemize}

\item (Zad. 3, cz. 2, 06.2017) Skonstruuj strukturę danych, która umożliwia efektywne wykonywanie następujących operaci na $n$, początkowo wyzerowanych, licznikach: 
\begin{itemize}
\item \textit{inc($k$)} - zwiększ o $1$ wartość $k$-tego licznika
\item \textit{settomax()} - ustaw wszystkie liczniki na maksymalną (w momencie wykonywania tej operacji) wartość licznika
\item \textit{get($k$)} - wypisz wartość $k$-tego licznika


\end{itemize}


\end{enumerate}




\section*{Zadania z części 3.}
\begin{enumerate}

\item (Zad. 1, cz. 3, 06.2017) Ciąg nazywamy nienudnym, jeżeli każdy jego spójny podciąg zawiera co najmniej jedne unikalny element (tzn. występujący w tym podciągu dokładnie raz). Ułóż algorytm, który dla danego ciągu liczb naturalnych sprawdzi, czy jest on nienudny.

\item (Zad. 2, cz. 3, 06.2017) Wariancją ciągu liczbowego $A = \langle a_1, ..., a_n \rangle $ nazywamy liczbę 
$$V_A = \left\{\begin{array}{rcl}
0&gdy&n=1\\
\sum_{i=1}^{n-1} |a{i+1}-a_i|&gdy&n>1\\
\end{array} \right.$$
ułóż algorytm, który dla zadanego ciągu liczbowego A znajdzie podział zbioru indeksów $\{1,2\ldots,n\}$ na dwa rozłączne podzbiory $I = \{i_1,i_2\ldots,i_k\}$ oraz $J = \{j_1,j_2\ldots,j_{n-k}\}$ takie, że:
\begin{itemize}
	\item $ i_1 < i_2 < \ldots < i_l$, $ j_1, j_2, \ldots, j_{n-k}$ oraz $I \cup J = \{1,2\ldots,n\}$
	\item suma $V_{A_I} oraz V_{A_J}$ jest minimalna, 
\end{itemize}
gdzie $A_I = \langle x_{i_1}, \ldots, x_{i_k} \rangle$, a $A_J = \langle x_{j_1}, \ldots, x_{k_{n-k}} \rangle$,  

\item (Zad. 3, cz. 3, 06.2017) Rozważamy ciąg operacji \textit{Insert(i)}, \textit{DeleteMin} oraz \textit{Min(i)} wykonywanych na $S$-podzbiorze zbioru $\{1,\ldots,n\}$. Obliczenia rozpoczynami z $S = \phi$. Instrukcja \textit{Insert(i)} wstawia liczbę $i$ do $S$. Instruckja \textit{DeleteMin} wyznacza najmniejszy element w $S$ i usuwa go z $S$. Natomiast wykonanie \textit{Min(i)} polega na usunięciu z $S$ wszystkich liczb mniejszych od $i$. \\
Niech $\rho$ będzie ciągiem instrukcji $Insert(i)$, $DeleteMin$ oraz $Min(i)$ takimi, że dla każdego $i$, $1\leq i \leq n$, instrukcja $Inser(i)$ występuje co najwyżej jeden raz. Mając dany ciąg $\rho$ naszym zadaniem jest znaleźć ciąg liczb usuwanych kolejno przez instrukcję $DeleteMin$. Podaj algorytm rozwiązujący to zadanie. \\
\textbf{Uwaga:} \textit{Zakładamy, że cały ciąg $\rho$ jest znany na początku, czyli interesuje nas wykonanie go off-line}

\item (Zad. 4, cz. 3, 06.2017) Rozpiętością ciągu liczbowego $A = \langle a_1, ..., a_n \rangle $ nazywamy liczbę:
$$Span(A) = max \{a_i | i = 1,\ldots,n\} - min\{a_i | i = 1,\ldots,n\}$$
Ułoż algorytm obliczający 
$$ \sum_{1 \leq p \leq k \leq n} Span(A_p^k)$$
gdzie $A_p^k = \langle a_p,\ldots,a_k \rangle$

\end{enumerate}


\end{document}
